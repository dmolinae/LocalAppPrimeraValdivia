<#@ Include File="TemplateHeader.t4" #>
<#@ Modeling ElementType="Microsoft.VisualStudio.Uml.Classes.IClass" Processor="ModelingProcessor" ApplyStereotypes="CSharp" #>
<#@ Import Namespace="Microsoft.VisualStudio.Uml.AuxiliaryConstructs" #>
<#@ Import Namespace="Microsoft.VisualStudio.Uml.Classes" #>
<#@ Import Namespace="Microsoft.VisualStudio.ArchitectureTools.Extensibility.Uml" #>
<#@ Include File="CSharpCommentHelpers.t4" #>
<#@ Include File="CSharpHelpers.t4" #>
<#@ Output Extension=".cs" #>
<# 
    String clase = ClassifierName(this.Element);
    var atributos = this.Element.OwnedAttributes;
    int len = 0;
    String pk_name = "";
    String pk_type = "";
    foreach(IProperty atributo in atributos)
    {
        if(len == 0)
        {
            pk_name = atributo.Name;
            pk_type = atributo.Signature.Split(':')[1].Trim();
        }
        len = len +1;
    }
#>


using PrimeraValdivia.ViewModels;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Data;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace PrimeraValdivia.Models
{
    class <#= clase #> : ViewModelBase
    {
        private Utils utils = new Utils();
        private string query;

        #region Atributos
        <#
            // Write Attributes
            
            foreach(IProperty atributo in atributos)
            {
                string name = atributo.Name;
                string type = atributo.Signature.Split(':')[1].Trim();

                WriteLine("");
                WriteLine("\t\t"+"private "+type+" _"+name+";");
                WriteLine("\t\t"+"public "+type+" "+name);
                WriteLine("\t\t"+"{");
                WriteLine("\t\t\t"+"get { return _"+name+"; }");
                WriteLine("\t\t\t"+"set");
                WriteLine("\t\t\t"+"{");
                WriteLine("\t\t\t\t_"+name+" = value;");
                WriteLine("\t\t\t\t"+"OnPropertyChanged(\""+name+"\");");
                WriteLine("\t\t\t"+"}");
                WriteLine("\t\t"+"}");
            }
            WriteLine("");
        #>

        #endregion

        #region Metodos

        public <#= clase #>()
        {

        }

        <#
            Write("public "+clase+"(");
            int count = 0;
            foreach(IProperty atributo in atributos)
            {
                string name = atributo.Name;
                string type = atributo.Signature.Split(':')[1].Trim();

                if(count < len - 1) Write(type+" "+name+", ");
                else WriteLine(type+" "+name+")");

                count = count + 1;
            }
            WriteLine("\t\t"+"{");
            foreach(IProperty atributo in atributos)
            {
                string name = atributo.Name;

                WriteLine("\t\t\t"+"this."+name+" = "+name+";");
            }
            WriteLine("\t\t"+"}");
        #>

        <#
            WriteLine("public void Agregar"+clase+"("+clase+" "+clase+")");
            WriteLine("\t\t"+"{");
            WriteLine("\t\t\t"+"query = String.Format(");
            Write("\t\t\t\t"+"\"INSERT INTO "+clase+"(");

            count = 0;
            foreach(IProperty atributo in atributos)
            {
                string name = atributo.Name;
                
                if(count < len - 1) Write(name+",");
                else Write(name+")");

                count = count + 1;
            }
            Write(" VALUES(");
            count = 0;
            foreach(IProperty atributo in atributos)
            {
                string type = atributo.Signature.Split(':')[1].Trim();

                if(count < len - 1)
                {
                    if(type == "String" || type == "DateTime") Write("'{"+count+"}',");
                    else Write("{"+count+"},");
                }
                else
                {
                    if(type == "String" || type == "DateTime") WriteLine("'{"+count+"}')\",");
                    else WriteLine("{"+count+"})\",");
                }
                count = count + 1;
            }
            count = 0;
            foreach(IProperty atributo in atributos)
            {
                string name = atributo.Name;
                string type = atributo.Signature.Split(':')[1].Trim();

				if(type == "bool")
				{
					if(count < len - 1) WriteLine("\t\t\t\t("+clase+"."+name+")? 1 : 0,");
					else WriteLine("\t\t\t\t("+clase+"."+name+")? 1 : 0");
                }
				else
				{
					if(count < len - 1) WriteLine("\t\t\t\t"+clase+"."+name+",");
					else WriteLine("\t\t\t\t"+clase+"."+name+"");
                }

                count = count + 1;
            }
            WriteLine("\t\t\t\t);");
            WriteLine("\t\t\tutils.ExecuteNonQuery(query);");
            WriteLine("\t\t}");
        #>

        <#
            WriteLine("public void Editar"+clase+"("+clase+" "+clase+", "+pk_type+" "+pk_name+")");
            WriteLine("\t\t"+"{");
            WriteLine("\t\t\t"+"query = String.Format(");
            Write("\t\t\t\t"+"\"UPDATE "+clase+" SET ");

            count = 0;
            foreach(IProperty atributo in atributos)
            {
                string name = atributo.Name;
                string type = atributo.Signature.Split(':')[1].Trim();
                
                if(count < len - 1)
                {
                    if(type == "String" || type == "DateTime") Write(name+" = "+"'{"+count+"}', ");
                    else Write(name+" = "+"{"+count+"}, ");
                }
                else
                {
                    if(type == "String" || type == "DateTime") Write(name+" = "+"'{"+count+"}' ");
                    else Write(name+" = "+"{"+count+"} ");
                }
                count = count + 1;
            }
            count = 0;
            foreach(IProperty atributo in atributos)
            {
                string name = atributo.Name;
                string type = atributo.Signature.Split(':')[1].Trim();
                
                if(count == 0)
                {
                    if(type == "String") WriteLine("WHERE "+name+" = '{"+len+"}'\",");
                    else WriteLine("WHERE "+name+" = {"+len+"}\",");
                }

				if(type == "bool") WriteLine("\t\t\t\t("+clase+"."+name+")? 1 : 0,");
				else WriteLine("\t\t\t\t"+clase+"."+name+",");

                count = count + 1;
            }
            WriteLine("\t\t\t\t"+pk_name);
            WriteLine("\t\t\t\t);");
            WriteLine("\t\t\tutils.ExecuteNonQuery(query);");
            WriteLine("\t\t}");
        #>

        <#
            WriteLine("public ObservableCollection<"+clase+"> "+"Obtener"+clase+"s()");
            WriteLine("\t\t{");

            WriteLine("\t\t\tObservableCollection<"+clase+"> "+clase+"s = new ObservableCollection<"+clase+">();");

            WriteLine("\t\t\tquery = \" SELECT * FROM "+clase+"\";");

            WriteLine("\t\t\tDataTable dt = utils.ExecuteQuery(query);");
            WriteLine("\t\t\tforeach (DataRow row in dt.Rows)");
            WriteLine("\t\t\t{");
            WriteLine("\t\t\t\t"+clase+" "+clase+" = new "+clase+"(");

            count = 0;
            foreach(IProperty atributo in atributos)
            {
                string name = atributo.Name;
                string type = atributo.Signature.Split(':')[1].Trim();
                
                if(count < len - 1)
                {
                    if(type == "int") WriteLine("\t\t\t\t\t"+"int.Parse(row[\""+name+"\"].ToString()),");
                    else if(type == "float") WriteLine("\t\t\t\t\t"+"float.Parse(row[\""+name+"\"].ToString()),");
                    else if(type == "DateTime") WriteLine("\t\t\t\t\t"+"DateTime.Parse(row[\""+name+"\"].ToString()),");
                    else if(type == "bool") WriteLine("\t\t\t\t\t"+"bool.Parse(row[\""+name+"\"].ToString()),");
                    else WriteLine("\t\t\t\t\t"+"row[\""+name+"\"].ToString(),");
                }
                else
                {
                    if(type == "int") WriteLine("\t\t\t\t\t"+"int.Parse(row[\""+name+"\"].ToString())");
                    else if(type == "float") WriteLine("\t\t\t\t\t"+"float.Parse(row[\""+name+"\"].ToString())");
                    else if(type == "DateTime") WriteLine("\t\t\t\t\t"+"DateTime.Parse(row[\""+name+"\"].ToString())");
                    else if(type == "bool") WriteLine("\t\t\t\t\t"+"bool.Parse(row[\""+name+"\"].ToString())");
                    else WriteLine("\t\t\t\t\t"+"row[\""+name+"\"].ToString()");
                }

                count = count + 1;
            }
            WriteLine("\t\t\t\t);");
            WriteLine("\t\t\t\t"+clase+"s.Add("+clase+");");
            WriteLine("\t\t\t}");
            WriteLine("\t\t\treturn "+clase+"s;");
            WriteLine("\t\t}");        
        #>

        <#
            WriteLine("public void IniciarId()");
            WriteLine("\t\t{");
            WriteLine("\t\t\tquery = \"SELECT count(*) FROM "+clase+"\";");
            WriteLine("\t\t\tDataTable dt = utils.ExecuteQuery(query);");
            WriteLine("\t\t\tforeach (DataRow row in dt.Rows)");
            WriteLine("\t\t\t{");

            if(pk_type == "int") WriteLine("\t\t\t\tthis."+pk_name+" = "+"int.Parse(row[0].ToString());");
            else if(pk_type == "float") WriteLine("\t\t\t\tthis."+pk_name+" = "+"float.Parse(row[0].ToString());");
            else if(pk_type == "DateTime") WriteLine("\t\t\t\tthis."+pk_name+" = "+"DateTime.Parse(row[0].ToString());");
            else if(pk_type == "bool") WriteLine("\t\t\t\tthis."+pk_name+" = "+"bool.Parse(row[0].ToString());");
            else WriteLine("\t\t\t\tthis."+pk_name+" = "+"row[0].ToString();");
            
            WriteLine("\t\t\t}");
            WriteLine("\t\t}");
        #>
        #endregion
    }
}





<#+
    #region Inheritance

    /// <summary>
    /// Gets the implemented and inherited types of the given class.
    /// </summary>
    /// <param name="aClass">The given class</param>
    /// <returns>implementedAndInherted types</returns>
    private static string ImplementedAndInheritedList(IClass aClass)
    {
        var list = ImplementedAndInheritedTypes(aClass);
        if(list.Any())
        {
            return " : " + string.Join(", ", list.Select(t => ElementType(t)));
        }
        else
        {
            return string.Empty;
        }
    }

    #endregion Inheritance

    #region Polymorphism

    /// <summary>
    /// Gets the overload option of the indexer.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="owner">The class</param>
    /// <returns>The overload option for the operation</returns>
    private static string ClassIndexerOverloadOption(IOperation operation, IClass owner)
    {
        return ClassOperationOverloadOption(operation, owner);
    }

    /// <summary>
    /// Gets the overload option of the method.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="owner">The class</param>
    /// <returns>The overload option for the operation</returns>
    private static string ClassMethodOverloadOption(IOperation operation, IClass owner)
    {
        if(string.IsNullOrEmpty(MethodPartialOption(operation)))
        {
            return ClassOperationOverloadOption(operation, owner);
        }
        else 
        {
            return string.Empty;
        }
    }

    /// <summary>
    /// Gets the overload option of the operation.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="owner">The class</param>
    /// <returns>The overload option for the operation</returns>
    private static string ClassOperationOverloadOption(IOperation operation, IClass owner)
    {
        string overload = string.Empty;
        if(!string.IsNullOrEmpty(OperationAbstractOption(operation)))
        {
            overload += "abstract ";
        }
        else if(IsInheritedMember(operation, owner))
        {
            overload += "override ";
            if(!string.IsNullOrEmpty(OperationSealedOption(operation)))
            {
                overload += "sealed ";
            }
        }
        else if(IsOverridable(operation, owner))
        {
            overload += "virtual ";
        }

        return overload;
    }

    /// <summary>
    /// Gets the overload option of the property.
    /// </summary>
    /// <param name="property">The property</param>
    /// <param name="owner">The class</param>
    /// <returns>The overload option for the property</returns>
    private static string ClassPropertyOverloadOption(IProperty property, IClass owner)
    {
        string overload = string.Empty;
        if(IsInheritedMember(property, owner))
        {
            overload = "override ";
            if(!string.IsNullOrEmpty(PropertySealedOption(property)))
            {
                overload += "sealed ";
            }
        }
        else if(IsOverridable(property, owner))
        {
            overload += "virtual ";
        }

        return overload;
    }

    /// <summary>
    /// Checks if the operation is overridable.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="owner">The class</param>
    /// <returns>true if the operation is an inherited member.</returns>
    private static bool IsOverridable(IOperation operation, IClass owner)
    {
        bool isPrivate = MethodVisibility(operation) == "private " || IndexerVisibility(operation) == "private ";
        return !isPrivate && string.IsNullOrEmpty(OperationStaticOption(operation)) && string.IsNullOrEmpty(OperationSealedOption(operation)) && HasVirtualMembers(owner);
    }

    /// <summary>
    /// Checks if the property is overridable.
    /// </summary>
    /// <param name="property">The property</param>
    /// <param name="owner">The class</param>
    /// <returns>true if the property is an inherited member.</returns>
    private static bool IsOverridable(IProperty property, IClass owner)
    {
        bool isPrivate = FieldVisibility(property) == "private " || PropertyVisibility(property) == "private ";
        return !isPrivate && string.IsNullOrEmpty(AttributeStaticOption(property)) && string.IsNullOrEmpty(PropertySealedOption(property)) && HasVirtualMembers(owner);
    }

    /// <summary>
    /// Checks if the classifier could have virtual memebers.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>true if the property is an inherited member.</returns>
    private static bool HasVirtualMembers(IClass aClass)
    {
        return string.IsNullOrEmpty(ClassSealedOption(aClass)) && string.IsNullOrEmpty(ClassStaticOption(aClass));
    }

    /// <summary>
    /// Checks if the property is an inherited member.
    /// </summary>
    /// <param name="property">The property</param>
    /// <param name="owner">The owner class of the property</param>
    /// <returns>true if the property is an inherited member.</returns>
    private static bool IsInheritedMember(IProperty property, IClass owner)
    {
        var types = ImplementedOrInheritedTypes(owner);
        foreach(IType type in types) 
        {
            IClassifier baseClassifier = type as IClassifier;
            if(baseClassifier != null) 
            {
                ITemplateBinding templateBinding = GetTemplateBinding(baseClassifier);
                IClassifier bindingClassifier = GetBindingClassifier(templateBinding);
                if(bindingClassifier != null)
                {
                    baseClassifier = bindingClassifier;
                }

                foreach(IProperty propertyInBase in GetOwnedProperties(baseClassifier))
                {
                    bool isInheritedMember = IsInheritedMember(propertyInBase, property, templateBinding);
                    if(isInheritedMember)
                    {
                        return true;
                    }
                }
            }
        }

        return false;
    }

    /// <summary>
    /// Checks if the property is an inherited member.
    /// </summary>
    /// <param name="propertyInBase">The property in base</param>
    /// <param name="propertyInSubClass">The property in subclass</param>
    /// <param name="templateBinding">The template binding</param>
    /// <returns>true if the property in the subclass is an inherited member; false if it is not or the base is an interface</returns>
    private static bool IsInheritedMember(IProperty propertyInBase, IProperty propertyInSubClass, ITemplateBinding templateBinding)
    {
        var propertyInBaseOwner = propertyInBase.Owner;
        if(propertyInBaseOwner is IAssociation)
        {
            propertyInBaseOwner = ((IAssociation)propertyInBaseOwner).SourceElement;
        }

        if(propertyInBaseOwner is IInterface)
        {
            return false;
        }
        else if(propertyInBaseOwner is IClass)
        {
            bool isInheritedProperty = IsInheritedProperty(propertyInSubClass, propertyInBase, templateBinding);
            bool isOverridable = IsOverridable(propertyInBase, (IClass)propertyInBaseOwner);
            return isInheritedProperty && isOverridable;
        }
        
        return false;
    }
    
    /// <summary>
    /// Checks if the operation is an inherited member.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="owner">The owning class of the operation</param>
    /// <returns>true if the operation is an inherited member.</returns>
    private static bool IsInheritedMember(IOperation operation, IClass owner)
    {
        var types = ImplementedOrInheritedTypes(owner);
        foreach(IType type in types) 
        {
            IClassifier baseClassifier = type as IClassifier;
            if(baseClassifier != null) 
            {
                ITemplateBinding templateBinding = GetTemplateBinding(baseClassifier);
                IClassifier bindingClassifier = GetBindingClassifier(templateBinding);
                if(bindingClassifier != null)
                {
                    baseClassifier = bindingClassifier;
                }

                foreach(IOperation operationInBase in GetOwnedOperations(baseClassifier))
                {
                    bool isInheritedMember = IsInheritedMember(operationInBase, operation, templateBinding);
                    if(isInheritedMember)
                    {
                        return true;
                    }
                }
            }
        }

        return false;
    }
    
    /// <summary>
    /// Checks if the operation is an inherited member.
    /// </summary>
    /// <param name="operationInBase">The operation in base</param>
    /// <param name="operationInSubClass">The operation in the subclass</param>
    /// <param name="templateBinding">The template binding</param>
    /// <returns>true if the operation in the subclass is an inherited member; false if it is not or the base is an interface</returns>
    private static bool IsInheritedMember(IOperation operationInBase, IOperation operationInSubClass, ITemplateBinding templateBinding)
    {
        var operationInBaseOwner = operationInBase.Owner;
        if(operationInBaseOwner is IAssociation)
        {
            operationInBaseOwner = ((IAssociation)operationInBaseOwner).SourceElement;
        }

        if(operationInBaseOwner is IInterface)
        {
            return false;
        }
        else if(operationInBaseOwner is IClass)
        {
            bool isInheritedOperation = IsInheritedOperation(operationInSubClass, operationInBase, templateBinding);
            bool isOverridable = IsOverridable(operationInBase, (IClass)operationInBaseOwner);
            return isInheritedOperation && isOverridable;
        }
        
        return false;
    }

    /// <summary>
    /// Checks if the operation in subclass is inherited from the operation in base.
    /// </summary>
    /// <param name="operationInSubClass">The operation in subClass</param>
    /// <param name="operationInBase">The operation in base</param>
    /// <param name="templateBinding">The template binding</param>
    /// <returns>if operation in subClass is inherited from the operation in base.</returns>
    private static bool IsInheritedOperation(IOperation operationInSubClass, IOperation operationInBase, ITemplateBinding templateBinding)
    {
        if(templateBinding == null)
        {
            return operationInSubClass.Signature == operationInBase.Signature;
        }

        if(operationInSubClass.Name != operationInBase.Name)
        {
            return false;
        }

        var subClassOperationOwnedParametersInOrder = GetOwnedParametersInOrder(operationInSubClass);
        var baseClassOperationOwnedParametersInOrder = GetOwnedParametersInOrder(operationInBase);
        int numOfSubClassOperationOwnedParameters = subClassOperationOwnedParametersInOrder.Count();
        if(numOfSubClassOperationOwnedParameters != baseClassOperationOwnedParametersInOrder.Count())
        {
            return false;
        }
       
        var parameterSubstitutions = templateBinding.ParameterSubstitutions;
         // find the newly defined template parameters
        var baseClassifier = (IClassifier)operationInBase.Owner;
        var subClassifier = (IClassifier)operationInSubClass.Owner;
        var subClassNewlyDefinedTemplateParameterNames = GetNewlyDefinedTemplateParameterNamesInSubClass(baseClassifier, subClassifier, parameterSubstitutions); 

        for(int i=0; i < numOfSubClassOperationOwnedParameters; i++)
        {
            var subClassOperationOwnedParameter = subClassOperationOwnedParametersInOrder.ElementAt(i);
            var baseClassOperationOwnedParameter = baseClassOperationOwnedParametersInOrder.ElementAt(i);
            if(subClassOperationOwnedParameter.Direction != baseClassOperationOwnedParameter.Direction)
            {
                return false;
            }

            bool isParameterInBaseEnumerable = IsEnumerable(baseClassOperationOwnedParameter);
            bool isParameterInSubClassEnumerable = IsEnumerable(subClassOperationOwnedParameter);
            if(isParameterInBaseEnumerable != isParameterInSubClassEnumerable)
            {
                return false;
            }

            if(!OneTypeOverridesTheOther(baseClassOperationOwnedParameter.Type, subClassOperationOwnedParameter.Type, parameterSubstitutions, subClassNewlyDefinedTemplateParameterNames))
            {
                return false;
            }
       }

       return true;
    }

    /// <summary>
    /// Gets the owned parameters in order: first is the parameter of return type, and then the rest of the parameters.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <returns>List of owned parameters in order</returns>
    private static List<IParameter> GetOwnedParametersInOrder(IOperation operation)
    {   
        var orderedSet = Enumerable.Union<IParameter>(operation.OwnedParameters.Where(parameter => parameter.Direction == ParameterDirectionKind.Return), operation.OwnedParameters.Where(parameter => parameter.Direction != ParameterDirectionKind.Return));
        return orderedSet.ToList();
    }

    /// <summary>
    /// Checks if the two type names are equal with considering of the template binding substitutions.
    /// </summary>
    /// <param name="propertyInSubClass">The property in subClass</param>
    /// <param name="propertyInBase">The property in base</param>
    /// <param name="templateBinding">The template binding</param>
    /// <returns>if property in subClass is inherited from the property in base.</returns>
    private static bool IsInheritedProperty(IProperty propertyInSubClass, IProperty propertyInBase, ITemplateBinding templateBinding)
    {
        if(templateBinding == null)
        {
            return propertyInSubClass.Signature == propertyInBase.Signature;
        }

        if(propertyInSubClass.Name != propertyInBase.Name)
        {
            return false;
        }
        
        bool isPropertyInBaseEnumerable = IsEnumerable(propertyInBase);
        bool isPropertyInSubClassEnumerable = IsEnumerable(propertyInSubClass);
        if(isPropertyInBaseEnumerable != isPropertyInSubClassEnumerable)
        {
            return false;
        }

        var parameterSubstitutions = templateBinding.ParameterSubstitutions;
        var subClassNewlyDefinedTemplateParameterNames = GetNewlyDefinedTemplateParameterNamesInSubClass(propertyInBase.Classifier, propertyInSubClass.Classifier, parameterSubstitutions); 

        return OneTypeOverridesTheOther(propertyInBase.Type, propertyInSubClass.Type, parameterSubstitutions, subClassNewlyDefinedTemplateParameterNames);
    }

    /// <summary>
    /// Checks if the type in subclass overrides the type in base.
    /// </summary>
    /// <param name="typeInBase">The type in base</param>
    /// <param name="typeInSubclass">The type in subclass</param>
    /// <param name="parameterSubstitutions">The parameter substitutions</param>
    /// <param name="newlyDefinedTemplateParameterNames">The newly defined template parameter names in subclass</param>
    /// <returns>true if the type in subclass overrides the type in the base; false otherwise</returns>
    private static bool OneTypeOverridesTheOther(IType typeInBase, IType typeInSubclass, IEnumerable<ITemplateParameterSubstitution> parameterSubstitutions, IEnumerable<string> newlyDefinedTemplateParameterNames)
    {
        // get name and template parameters for base
        List<string> baseTypeTemplateParametersNames = new List<string>();
        string baseTypeName = GetNameAndTemplateParameterNamesForType(typeInBase, out baseTypeTemplateParametersNames);

        // get name and template parameters for subclass
        List<string> subTypeTemplateParametersNames = new List<string>();
        string subTypeName = GetNameAndTemplateParameterNamesForType(typeInSubclass, out subTypeTemplateParametersNames);

        if(newlyDefinedTemplateParameterNames.Contains(subTypeName) || subTypeTemplateParametersNames.Where(name => newlyDefinedTemplateParameterNames.Contains(name)).Any())
        {
            return false;
        }

        int numberOfSubTypeTemplateParameters = subTypeTemplateParametersNames.Count();
        if(numberOfSubTypeTemplateParameters != baseTypeTemplateParametersNames.Count())
        {
            return false;
        }

        if(subTypeTemplateParametersNames.Any())
        {
            if(baseTypeName != subTypeName)
            {
                return false;
            }
            
            for(int i=0; i < numberOfSubTypeTemplateParameters; i++)
            {
                var subTypeTemplateParameterName = subTypeTemplateParametersNames.ElementAt(i);
                var baseTypeTemplateParameterName = baseTypeTemplateParametersNames.ElementAt(i);

                if(!OneTypeNameOverridesTheOther(baseTypeTemplateParameterName, subTypeTemplateParameterName, parameterSubstitutions))
                {
                    return false;
                }
            }

            return true;
        }
        else 
        {
            return OneTypeNameOverridesTheOther(baseTypeName, subTypeName, parameterSubstitutions);
        }
    }
    
    /// <summary>
    /// Checks if the type name in subclass overrides the type name in base.
    /// </summary>
    /// <param name="baseTypeName">The type name in base</param>
    /// <param name="subTypeName">The type name in subclass</param>
    /// <param name="parameterSubstitutions">The parameter substitutions</param>
    /// <returns>true if the type name in subclass could override the type in the base; false otherwise</returns>
    private static bool OneTypeNameOverridesTheOther(string baseTypeName, string subTypeName, IEnumerable<ITemplateParameterSubstitution> parameterSubstitutions)
    {
        bool found = false;
        bool hasSubstitution = false;
        foreach(var substitution in parameterSubstitutions)
        {
            if(substitution.Formal.ParameteredElement.Name == baseTypeName)
            {
                hasSubstitution = true;
                INamedElement actual = substitution.Actuals.FirstOrDefault();
                if(actual != null && subTypeName == actual.Name) 
                {
                    found = true;
                    break;
                }
            }
        }

        if(hasSubstitution && !found)
        {
            return false;
        }

        if(!hasSubstitution && baseTypeName != subTypeName)
        {
            return false;
        }

        return true;
    }

    /// <summary>
    /// Gets the name and template parameter names as a list for the given type.
    /// </summary>
    /// <param name="aType">the type to query</param>
    /// <param name="templateParameterNames">the template parameter names for the type</param>
    /// <returns>The type name</returns>
    private static string GetNameAndTemplateParameterNamesForType(IType aType, out List<string> templateParameterNames) 
    {
        string typeName = null;
        IClassifier classifier = aType as IClassifier;
        templateParameterNames = new List<string>();
        if(classifier != null)
        {
            templateParameterNames = GetNameAndTemplateParameterNamesForClassifier(classifier);
            if(templateParameterNames.Any())
            {
                typeName = templateParameterNames.ElementAt(0);
                templateParameterNames.RemoveAt(0);
            }
        }
        else 
        {
            typeName = ElementType(aType);
        }    

        return typeName;
    }

    /// <summary>
    /// Gets the classifier name and template parameter names as a list.
    /// </summary>
    /// <param name="classifier">the classifier to query</param>
    /// <returns>a list of classifier name and template parameter names for the given classifier</returns>
    private static List<string> GetNameAndTemplateParameterNamesForClassifier(IClassifier classifier) 
    {
        return ClassifierProperty(element => { return GetName(element); }, GetUnboundClassifierName, SimpleAssemble, classifier).ToList();
    }

    /// <summary>
    /// Gets the classifier name and template parameter names as a list.
    /// </summary>
    /// <param name="baseClass">the base class</param>
    /// <param name="subClass">the sub class</param>
    /// <param name="parameterSubstitutions">the parameter substitutions</param>
    /// <returns>The template parameter newly defined in the subclass</returns>
    private static IEnumerable<string> GetNewlyDefinedTemplateParameterNamesInSubClass(IClassifier baseClassifier, IClassifier subClassifier, IEnumerable<ITemplateParameterSubstitution> parameterSubstitutions)
    {
        var baseClassTemplateParameterNames = TemplateParameterNames(baseClassifier);
        var substitutedTemplateParameterNames = GetSubstitutedTemplateParameterNames(parameterSubstitutions);
        var nonSubstitutedTemplateParameterNames = baseClassTemplateParameterNames.Where(name => !substitutedTemplateParameterNames.Contains(name));

        var subClassTemplateParameterNames = TemplateParameterNames(subClassifier);
        return subClassTemplateParameterNames.Where(name => !nonSubstitutedTemplateParameterNames.Contains(name));
    }

    /// <summary>
    /// Gets the list of template parameter names that are substituted.
    /// </summary>
    /// <param name="parameterSubstitutions">the parameter substitutions</param>
    /// <returns>The list of template parameter names that are substituted.</returns>
    private static List<string> GetSubstitutedTemplateParameterNames(IEnumerable<ITemplateParameterSubstitution> templateParameterSubstitutions)
    {
        List<string> substitutedParameterNames = new List<string>();
        foreach(var substitute in templateParameterSubstitutions)
        {
            string formalName = substitute.Formal.ParameteredElement.Name;
            string actualName = null;
            if(substitute.Actuals.Any())
            {
                actualName = substitute.Actuals.ElementAt(0).Name;
            }

            if(!string.IsNullOrWhiteSpace(formalName))
            {
                if(!string.IsNullOrWhiteSpace(actualName) && formalName == actualName)
                {
                    continue;
                }
                else 
                {
                    substitutedParameterNames.Add(formalName);
                }
            }
        }

        return substitutedParameterNames;
    }

    /// <summary>
    /// Gets the owned attributes for the given classifier.
    /// </summary>
    /// <param name="classifier">The classifier</param>
    /// <returns>The owned attributes</returns>
    private static IEnumerable<IProperty> GetOwnedProperties(IClassifier classifier)
    {
        var ownedAttributes= GetOwnedAttributes(classifier);
        var navigableOwnedEnds = GetNavigableOwnedEnds(classifier, ownedAttributes);
        return Enumerable.Union<IProperty>(ownedAttributes, navigableOwnedEnds);
    }

    /// <summary>
    /// Gets the owned attributes for the given classifier.
    /// </summary>
    /// <param name="classifier">The classifier</param>
    /// <returns>The owned attributes</returns>
    private static IEnumerable<IProperty> GetOwnedAttributes(IClassifier classifier)
    {
        if(classifier is IClass)
        {
            return ((IClass)classifier).OwnedAttributes;
        }
        else if(classifier is IInterface)
        {
            return ((IInterface)classifier).OwnedAttributes;
        }

        return Enumerable.Empty<IProperty>();
    }

    /// <summary>
    /// Gets the owned operations for the given classifier.
    /// </summary>
    /// <param name="classifier">The classifier</param>
    /// <returns>The owned operations</returns>
    private static IEnumerable<IOperation> GetOwnedOperations(IClassifier classifier)
    {
        if(classifier is IClass)
        {
            return ((IClass)classifier).OwnedOperations;
        }
        else if(classifier is IInterface)
        {
            return ((IInterface)classifier).OwnedOperations;
        }

        return Enumerable.Empty<IOperation>();
    }

    #endregion Polymorphism

    #region Class property options

    /// <summary>
    /// Gets the sealed option.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>The sealed keyword option</returns>
    private static string ClassSealedOption(IClass aClass)
    {
        return aClass.IsLeaf ? "sealed " : string.Empty;
    }

    /// <summary>
    /// Gets the abstract option.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>The abstract keyword option</returns>
    private static string ClassAbstractOption(IClass aClass)
    {
        return aClass.IsAbstract ? "abstract " : string.Empty;
    }

    /// <summary>
    /// Gets the unsafe option.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>The static keyword option</returns>
    private static string ClassUnsafeOption(IClass aClass) 
    {
        return GetProperty(aClass, "class", "IsUnsafe", "unsafe");
    }

    /// <summary>
    /// Gets the static option.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>The static keyword option</returns>
    private static string ClassStaticOption(IClass aClass) 
    {
        return GetProperty(aClass, "class", "IsStatic", "static");
    }

    /// <summary>
    /// Gets the partial option.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>The partial keyword option</returns>
    private static string ClassPartialOption(IClass aClass) 
    {
        return GetProperty(aClass, "class", "IsPartial", "partial");
    }

    #endregion Class property options

    #region Operations

    /// <summary>
    /// Check if the operation is a destructor.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <returns>true if the operation is a destructor.</returns>
    private static bool IsDestructor(IOperation operation)
    {
        if (operation.Owner is IClassifier)
        {
            IClassifier owner = (IClassifier)operation.Owner;
            return operation.Name == "~" + owner.Name;
        }

        return false;
    }

    /// <summary>
    /// Write UmlProperty definition.
    /// </summary>
    /// <param name="property">The uml IProperty</param>
    private void WriteClassUmlPropertyDefinition(IProperty property)
    {
        string overloadOption = ClassPropertyOverloadOption(property, this.Element);
        WriteUmlPropertyDefinition(property, overloadOption);
    }

    /// <summary>
    /// Write the method body
    /// </summary>
    /// <param name="operation">The operation</param>
    private void WriteClassMethodBody(IOperation operation)
    {
        if(!operation.IsAbstract && string.IsNullOrEmpty(MethodPartialOption(operation)))
        {
            WriteDefaultImplementation();
        }
        else
        {
            Write(";");
            WriteLine("");
        }
    }

    /// <summary>
    /// Writes the indexer accessor body.
    /// </summary>
    /// <param name="operation">The operation</param>
    private void WriteClassIndexerAccessorBody(IOperation operation)
    {
        WriteClassMethodBody(operation);
    }

    #endregion Operations

    #region Visibility

    /// <summary>
    /// Returns the visibility of the given class.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>public, protected, protected internal, internal, or private</returns>
    private static string ClassVisibility(IClass aClass)
    {
        return Visibility(aClass, "class", "PackageVisibility");
    }

    #endregion Visibility
#>